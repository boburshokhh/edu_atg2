from __future__ import annotations

from django.utils import timezone
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed

from apps.accounts.jwt_utils import JwtError, verify_access
from apps.accounts.models import User, UserSession


class AccessJWTAuthentication(BaseAuthentication):
    """
    Bearer <access_jwt>
    Payload compatible with existing Node API: { sub, username, role }.
    """

    def authenticate(self, request):
        header = request.headers.get("Authorization") or ""
        if not header.startswith("Bearer "):
            return None

        token = header[len("Bearer ") :].strip()
        if not token:
            return None

        try:
            payload = verify_access(token)
        except JwtError:
            # Soft-fail: treat invalid/legacy tokens (e.g. session_*) as anonymous,
            # so AllowAny endpoints keep working.
            return None

        user_id = payload.get("sub")
        if not user_id:
            return None

        try:
            user = User.objects.get(id=user_id, is_active=True)
        except User.DoesNotExist:
            raise AuthenticationFailed("Unauthorized")

        request.jwt = payload
        return (user, None)



class SessionTokenAuthentication(BaseAuthentication):
    """
    Bearer <session_token>
    where token is generated by frontend auth service and stored in `user_sessions`.

    IMPORTANT:
    - Soft-fail on invalid/expired tokens to keep AllowAny endpoints working even if a client
      still sends an old Authorization header (same behavior as AccessJWTAuthentication).
    """

    def authenticate(self, request):
        import logging
        logger = logging.getLogger(__name__)
        
        header = request.headers.get("Authorization") or ""
        logger.debug(f"[SessionTokenAuth] Authorization header: {header[:50]}...")
        
        if not header.startswith("Bearer "):
            logger.debug("[SessionTokenAuth] No Bearer prefix")
            return None

        token = header[len("Bearer ") :].strip()
        if not token:
            logger.debug("[SessionTokenAuth] Empty token")
            return None

        # Only handle session-style tokens here
        if not token.startswith("session_"):
            logger.debug(f"[SessionTokenAuth] Token doesn't start with 'session_': {token[:20]}...")
            return None

        logger.debug(f"[SessionTokenAuth] Looking up session for token: {token[:30]}...")
        session = (
            UserSession.objects.select_related("user")
            .filter(session_token=token, expires_at__gt=timezone.now())
            .first()
        )

        if not session:
            logger.warning(f"[SessionTokenAuth] Session not found or expired for token: {token[:30]}...")
            return None
            
        if not session.user:
            logger.warning(f"[SessionTokenAuth] Session has no user")
            return None
            
        if not session.user.is_active:
            logger.warning(f"[SessionTokenAuth] User {session.user.id} is not active")
            return None

        logger.info(f"[SessionTokenAuth] Authenticated user: {session.user.id} (role: {session.user.role})")
        
        # Best-effort update last_activity (model has auto_now=True but only updates on save)
        try:
            session.save(update_fields=["last_activity"])
        except Exception:
            pass

        request.session_token = token
        return (session.user, None)

