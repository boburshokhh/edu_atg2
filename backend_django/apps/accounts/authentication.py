from __future__ import annotations

from django.utils import timezone
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed

from apps.accounts.jwt_utils import JwtError, verify_access, verify_pending_registration
from apps.accounts.models import User, UserSession


class AccessJWTAuthentication(BaseAuthentication):
    """
    Bearer <access_jwt>
    Payload compatible with existing Node API: { sub, username, role }.
    """

    def authenticate(self, request):
        header = request.headers.get("Authorization") or ""
        if not header.startswith("Bearer "):
            return None

        token = header[len("Bearer ") :].strip()
        if not token:
            return None

        try:
            payload = verify_access(token)
        except JwtError:
            # Soft-fail: treat invalid/legacy tokens (e.g. session_*) as anonymous,
            # so AllowAny endpoints keep working.
            return None

        user_id = payload.get("sub")
        if not user_id:
            return None

        try:
            user = User.objects.get(id=user_id, is_active=True)
        except User.DoesNotExist:
            raise AuthenticationFailed("Unauthorized")

        request.jwt = payload
        return (user, None)



class SessionTokenAuthentication(BaseAuthentication):
    """
    Bearer <session_token>
    where token is generated by frontend auth service and stored in `user_sessions`.

    IMPORTANT:
    - Soft-fail on invalid/expired tokens to keep AllowAny endpoints working even if a client
      still sends an old Authorization header (same behavior as AccessJWTAuthentication).
    """

    def authenticate(self, request):
        import logging
        logger = logging.getLogger(__name__)
        
        header = request.headers.get("Authorization") or ""
        logger.debug(f"[SessionTokenAuth] Authorization header: {header[:50]}...")
        
        if not header.startswith("Bearer "):
            logger.debug("[SessionTokenAuth] No Bearer prefix")
            return None

        token = header[len("Bearer ") :].strip()
        if not token:
            logger.debug("[SessionTokenAuth] Empty token")
            return None

        # Only handle session-style tokens here
        if not token.startswith("session_"):
            logger.debug(f"[SessionTokenAuth] Token doesn't start with 'session_': {token[:20]}...")
            return None

        logger.debug(f"[SessionTokenAuth] Looking up session for token: {token[:30]}...")
        session = (
            UserSession.objects.select_related("user")
            .filter(session_token=token, expires_at__gt=timezone.now())
            .first()
        )

        if not session:
            logger.warning(f"[SessionTokenAuth] Session not found or expired for token: {token[:30]}...")
            return None
            
        if not session.user:
            logger.warning(f"[SessionTokenAuth] Session has no user")
            return None
            
        if not session.user.is_active:
            logger.warning(f"[SessionTokenAuth] User {session.user.id} is not active")
            return None

        logger.info(f"[SessionTokenAuth] Authenticated user: {session.user.id} (role: {session.user.role})")
        
        # Best-effort update last_activity (model has auto_now=True but only updates on save)
        try:
            session.save(update_fields=["last_activity"])
        except Exception:
            pass

        request.session_token = token
        return (session.user, None)


class PendingRegistrationAuthentication(BaseAuthentication):
    """
    Bearer <pending_registration_token>
    Handles authentication for users who have authenticated via LDAP but haven't completed registration yet.
    Creates a temporary User object from token data for use in registration endpoints.
    """
    
    def authenticate(self, request):
        import logging
        logger = logging.getLogger(__name__)
        
        header = request.headers.get("Authorization") or ""
        if not header.startswith("Bearer "):
            return None
        
        token = header[len("Bearer ") :].strip()
        if not token:
            return None
        
        try:
            payload = verify_pending_registration(token)
        except JwtError:
            logger.debug("[PendingRegAuth] Invalid pending registration token")
            return None
        
        # Create a temporary User object from token data
        # This user doesn't exist in DB yet, but we need it for registration endpoint
        from apps.accounts.models import User as UserModel
        from uuid import UUID
        
        # Generate a temporary UUID from username hash (deterministic)
        import hashlib
        username_hash = hashlib.md5(payload.get("username", "").encode()).hexdigest()
        temp_id = UUID(f"00000000-0000-0000-0000-{username_hash[:12]}")
        
        # Create a temporary user object (not saved to DB)
        temp_user = UserModel(
            id=temp_id,
            username=payload.get("username", "")[:50],
            password="",  # Not used for pending registration
            full_name=payload.get("full_name", "")[:100],
            email=payload.get("email", "")[:100],
            role=payload.get("role", "user"),
            is_active=True,
        )
        
        # Add is_authenticated property (required by DRF)
        temp_user.is_authenticated = True
        
        # Store LDAP data in request for use in registration
        request.pending_registration_data = {
            "username": payload.get("username", ""),
            "email": payload.get("email", ""),
            "full_name": payload.get("full_name", ""),
            "phone": payload.get("phone", ""),
            "department": payload.get("department", ""),
            "position": payload.get("position", ""),
            "role": payload.get("role", "user"),
            "token": token,
        }
        
        logger.info(f"[PendingRegAuth] Authenticated pending registration for: {payload.get('username')}")
        return (temp_user, None)

