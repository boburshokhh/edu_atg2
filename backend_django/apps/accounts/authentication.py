from __future__ import annotations

from django.utils import timezone
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed

from apps.accounts.jwt_utils import JwtError, verify_access
from apps.accounts.models import LdapTempSession, User, UserSession


class AccessJWTAuthentication(BaseAuthentication):
    """
    Bearer <access_jwt>
    Payload compatible with existing Node API: { sub, username, role }.
    """

    def authenticate(self, request):
        header = request.headers.get("Authorization") or ""
        if not header.startswith("Bearer "):
            return None

        token = header[len("Bearer ") :].strip()
        if not token:
            return None

        try:
            payload = verify_access(token)
        except JwtError:
            # Soft-fail: treat invalid/legacy tokens (e.g. session_*) as anonymous,
            # so AllowAny endpoints keep working.
            return None

        user_id = payload.get("sub")
        if not user_id:
            return None

        # Temporary LDAP sessions (first-time registration):
        # sub format: "temp:<uuid>"
        if isinstance(user_id, str) and user_id.startswith("temp:"):
            temp_id = user_id[len("temp:") :].strip()
            try:
                session = (
                    LdapTempSession.objects.filter(id=temp_id, expires_at__gt=timezone.now())
                    .first()
                )
            except Exception:
                session = None
            if not session:
                raise AuthenticationFailed("Unauthorized")

            class TempUser:
                # Minimal DRF user contract
                def __init__(self, s: LdapTempSession):
                    self.id = s.id
                    self.username = s.ldap_username
                    self.role = "user"
                    self.is_active = True

                @property
                def is_authenticated(self) -> bool:
                    return True

            request.jwt = payload
            request.ldap_temp_session = session
            return (TempUser(session), None)

        try:
            user = User.objects.get(id=user_id, is_active=True)
        except User.DoesNotExist:
            raise AuthenticationFailed("Unauthorized")

        request.jwt = payload
        return (user, None)



class SessionTokenAuthentication(BaseAuthentication):
    """
    Bearer <session_token>
    where token is generated by frontend auth service and stored in `user_sessions`.

    IMPORTANT:
    - Soft-fail on invalid/expired tokens to keep AllowAny endpoints working even if a client
      still sends an old Authorization header (same behavior as AccessJWTAuthentication).
    """

    def authenticate(self, request):
        import logging
        logger = logging.getLogger(__name__)
        
        header = request.headers.get("Authorization") or ""
        logger.debug(f"[SessionTokenAuth] Authorization header: {header[:50]}...")
        
        if not header.startswith("Bearer "):
            logger.debug("[SessionTokenAuth] No Bearer prefix")
            return None

        token = header[len("Bearer ") :].strip()
        if not token:
            logger.debug("[SessionTokenAuth] Empty token")
            return None

        # Only handle session-style tokens here
        if not token.startswith("session_"):
            logger.debug(f"[SessionTokenAuth] Token doesn't start with 'session_': {token[:20]}...")
            return None

        logger.debug(f"[SessionTokenAuth] Looking up session for token: {token[:30]}...")
        session = (
            UserSession.objects.select_related("user")
            .filter(session_token=token, expires_at__gt=timezone.now())
            .first()
        )

        if not session:
            logger.warning(f"[SessionTokenAuth] Session not found or expired for token: {token[:30]}...")
            return None
            
        if not session.user:
            logger.warning(f"[SessionTokenAuth] Session has no user")
            return None
            
        if not session.user.is_active:
            logger.warning(f"[SessionTokenAuth] User {session.user.id} is not active")
            return None

        logger.info(f"[SessionTokenAuth] Authenticated user: {session.user.id} (role: {session.user.role})")
        
        # Best-effort update last_activity (model has auto_now=True but only updates on save)
        try:
            session.save(update_fields=["last_activity"])
        except Exception:
            pass

        request.session_token = token
        return (session.user, None)

