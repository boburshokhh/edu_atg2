server {
    listen 80;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    # MIME types:
    # - Some deployments were serving .mjs as application/octet-stream, which breaks
    #   strict module loading (e.g., pdf.js worker).
    # - We include the standard mapping and then add/override a few missing ones.
    include /etc/nginx/mime.types;
    types {
        application/javascript  mjs;
        application/wasm        wasm;
    }

    # Maximum upload chunk size (multipart uploads handled by backend)
    client_max_body_size 50M;
    client_body_timeout 600s;
    client_body_buffer_size 128k;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/x-javascript application/xml+rss application/json application/wasm;

    # Frontend -> Backend (Django) inside Docker network
    # /api/auth/login  -> http://backend:8000/auth/login
    location /api/ {
        rewrite ^/api(/.*)$ $1 break;
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeouts - reduced for login to fail faster if backend is down
        # But still allow enough time for LDAP authentication
        proxy_connect_timeout 10s;
        proxy_send_timeout 600s;
        proxy_read_timeout 600s;
        
        # Better error handling
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
        proxy_next_upstream_tries 1;
        proxy_next_upstream_timeout 0;
        
        # Increase buffer sizes for large uploads
        proxy_request_buffering off;
        proxy_buffering off;
        
        # Error pages
        proxy_intercept_errors on;
        error_page 502 503 504 = @backend_error;
    }
    
    # Custom error handler for backend errors
    location @backend_error {
        default_type application/json;
        return 502 '{"error": "Backend service unavailable", "message": "The backend server is not responding. Please check if the backend container is running."}';
    }

    # Frontend -> MinIO inside Docker network (same-origin, avoids CORS)
    # IMPORTANT: keep Host stable for presigned URLs (SignedHeaders=host)
    # Presigned URLs are signed with hostname "minio:9000", so we must set Host header to "minio:9000"
    # to match the signature. The path includes bucket name (e.g., /atgedu/stations/...)
    location /api/minio/ {
        # Remove /api/minio prefix and proxy to MinIO
        rewrite ^/api/minio/(.*)$ /$1 break;
        proxy_pass http://minio:9000;
        # CRITICAL: Set Host to minio:9000 to match presigned URL signature
        proxy_set_header Host minio:9000;
        proxy_http_version 1.1;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Preserve query string (contains signature parameters: AWSAccessKeyId, Signature, Expires)
        proxy_pass_request_headers on;
    }

    # Serve static files
    location / {
        try_files $uri $uri/ /index.html;
    }
}

